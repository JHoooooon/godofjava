# Section 4

자바는 네가지 변수가 존재한다.
이를 담아두는 것을 변수라 한다.

```java
public class Calculator {
    /** args 역시 변수에 속한다. */
    public static void main(String[] args) {
        System.out.println("Calculator class started");

        /** 변수 */
        Calculator calc = new Calculator();

        /** 변수 */
        int a = 10
        int b = 5
    }
}
```

변수는 다음의 네가지 변수가 존재한다.

- 지역변수 (local variables): method 내에 사용된 variables
- 매개변수 (parameters): class, method 선언시 사용되는 Parameters
- 인스턴스 변수 (instance variables): class 내에 선언된 variables
- 클래스 변수 (class variables): class 내에서 선언된 static variables

이러한 변수의 생명주기는 전부 다르다.

- 지역변수 (local variables): 중괄호내에서만 유지<br>이는 `javascript` 와는 다르다.

- 매개변수 (parameters): method 실행기간까지 유지
- 인스턴스 변수 (instance variables): Instacne 가 참조할때까지 유지 (Garbage collector 사용으로 참조 count 가 0 이면, 삭제)
- 클래스 변수 (class variables): class 가 존재할때까지 유지


> `javascript` 에서 `let`, `const` 는 `중괄호` 까지 `block scope` 가 결정된다.
단, `block scope` 내에 다른 `block scope` 를 만들고,
같은 변수가 있을때,`Java` 처럼 `Error` 가 나지 않고,  
해당 `block scope` 내의 `block scope` 변수를 사용한다. 
이는 다음의 예제를 보면 이해할수 있다.

```java
public class Test() {
    public static void main(String[] args) {
        Test test = new Test();
        test.anotherMethod();
    }

    public void anotherMethod() {
        if (true) {
            int localVariable;
            if (true) {
                int localVariable; // Error: Duplicate local vraible localVariable
            }
        }
        if (true) {
            int localVariable;
        }
    }
}
```

```javascript
if (true) {
    let localVariable = '1';
    if (true) {
        let localVariable = '2'; 
        console.log(localVariable) // 2 출력
    }
}
```
`javascript` 와는 다르게, `Java` 에서는 같은 `scope` 내에서 중복된 `variables` 를 허용하지 않는다.
이는 `scope` 내의 `scope` 를 형성해도 마찬가지이다. 
이러한 동작방식의 다름으로, 충분히 헷갈릴 위험이 존재한다.

책에서는 다음처럼 하기를 권장한다

> "변수를 선언할때에는 되도록이면 하나의 메소드에는 하나의 이름만 사용하는 것을 권장한다."

## 크게보면 2개의 자료형이 있다.

기본 데이터 타입(`Primitive data type`) 과 참조 데이터 타입(`Reference data type`) 으로 나누어진다.
이는 단순하다. `Class` 를 사용하여, 해당 `new Class` 의 `Instance` 를 할당받는 변수면 참조데이터 타입이다.
나머지는, `Primitive data type` 으로 볼수 있다.

여기에는 문자열을 다루는 `String` 역시 `class` 로 볼수 있다.

```java
String bookName1 = 'God of Java';
```

이는 다음처럼도 가능하다.

```java
String bookName2 = new String('God of Java');
```

보면 알겠지만, `Class` 의 `Instance` 임을 볼수있다.
이는 `String Class` 자체가, 참조형이지만, 많이 사용하며 편의를 의해
마치 `Primitive data type` 처럼 되도록 편의를 제공한것으로 보는것이 적합하다.

> "String 만이, 참조 자료형 이지만, new 를 사용해서 객체를 생성하지 않아도 되는 유일한 타입이라고 알고 있으면 된다."

### 기본 자료형 (Primitive data type)

기본 자료형은 총 8 개이다.

- 정수형: byte, short, int, long, char
- 소수형: float, double
- 기타: boolean

다음은, 각 타입의 범위이다.

| 타입 | 최소 | 최대 |
| :--- | :--- | :--- |
| byte | -128 | 127 |
| short |  -32,768 | 32,767 |
| int |  -2,147,483,648 | 2,147,483,647 |
| long | -9,223,372,036,875,775,808 | 9,223,372,036,875,775,807 |
| char | 0('\u0000') | 65,535('\uffff') |

이는 실제 컴퓨터가 이해할수있는 이진수로 표현되어 있다.
프로그래밍에서 이러한 이진수로 표현한 `0` 과 `1` 의 최소 단위를 `bit`라 명한다.

만약 `8bit` 라 하면, 총 `8개의 0 과 1` 로 이루어진 것으로 생각하면 된다.

```sh
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
```

이는 이진수라 했으니, 십진수로 다음처럼 간주된다

```sh
| 2^7 | 2^6 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 |
```

즉 `1` 을 표현하려면 다음처럼 `2^0` 이 값이 `1` 이다.

```sh
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
```

그럼, 모든 진수가 `1` 로 채워져 있으면 몇일까??

```sh
binary | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
deciaml 128  64  32  16  8   4   2   1
```

총 `128 + 64 + 32 + 16 + 8 + 4 + 2 + 1` 로 `255` 임을 알수있다.
중요한점은 `0` 부터 시작하므로 `0 - 255` 까지의 수로 총 `256` 개의 수 표현이 가능하다.

즉, `8bit` 는 `1byte` 이므로, 표현가능한수는 `0 - 255` 까지이다.
하지만, `Java` 의 `byte` 타입은 `1byte` 임에도, `0 - 255` 가 아닌 `-128 ~ 127` 까지임을 볼수있다.
이는, 음수를 표현하기위해서, 맨 앞의 `bit` 가 `0` 이면 양수, `1` 이면 음수로 처리하기 때문이다.

```sh
     | signed bit |      표현가능한 수        |
양수 |     0      | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
음수 |     1      | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
```

이러한 방식으로 표현된다면, `표현가능한 수` 는 `2^7` 이 되므로 최대 표현수는 `127` 의 수가 된다.
그럼 양수는 `0 ~ 127` 까지 표현되며, 음수역시 `-0 ~ -127` 까지 표현할수있다.

하지만 여기서 문제가 있다. `0` 과 `-0` 은 그냥 `0` 이므로 `0` 이 겹친다.
`0` 이 겹친다면, 겹치는 `0` 을 제거하는것이 좋다.
이는 쓸데없이 컴퓨터의 자원을 낭비하게 된다.

이는 문제가 있다. 그러므로 다른 표현법을 사용하는데 다음과 같다
```sh
     | signed bit |      표현가능한 수        |
양수 |     0      | 1 | 1 | 1 | 1 | 1 | 1 | 1 | = 127
음수 |     1      | 0 | 0 | 0 | 0 | 0 | 0 | 0 | = -128
```

음수의 처음 `signed bit` 가 `1` 이면 `-128` 이 된다면, 해결가능하다.
만약 다음처럼 음수일때, 맨 마지막 `bit` 가 `1` 이면, 이는 `-127` 이 된다.
이는 다음처럼 표현가능하다.

```sh
     | signed bit |      표현가능한 수        |
음수 |     1      | 0 | 0 | 0 | 0 | 0 | 0 | 1 | = -127
음수 |     1      | 0 | 0 | 0 | 0 | 0 | 1 | 0 | = -126
음수 |     1      | 0 | 0 | 0 | 0 | 0 | 1 | 1 | = -125
음수 |     1      | 0 | 0 | 0 | 0 | 1 | 0 | 0 | = -124
...
음수 |     1      | 1 | 1 | 1 | 1 | 1 | 1 | 0 | = -2
음수 |     1      | 1 | 1 | 1 | 1 | 1 | 1 | 1 | = -1
양수 |     0      | 0 | 0 | 0 | 0 | 0 | 0 | 0 | = 0
```

이러한 방식으로 표현된다면, `0` 이 겹치지 않으며, 음수와 양수값을 표현할수 있다.
여기서 중요한점은 `0` 은 양수에 포함되므로, `0 ~ 127`(`128`개) 로 표현되고, 
음수는 `0` 이 없으므로 `-1 ~ -128`(`128` 개) 로 표현된다.

즉, 음수가 양수보다 `+1` 개더 표현가능하다는것이다.

이것이 맞는지 확인하는 방법으로 `2's complement` (2의 보수법) 을 사용할수 있다.
음수와 양수가 더할때 `0000_0000` 을 표현된다면, 이는 명확하게 사용가능됨을 증명할수 있다. 

```sh
     | signed bit |      표현가능한 수        |
양수 |     0      | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
음수 |     1      | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
```

위처럼 표현된 수가 있다고 하고, `0000_0000` 을 만들기 위해서는 어떻게 해야 할까?

```sh
  0111_1111
+ 1111_1111
=============
 10000_0000
```

이렇게 계산되며, 이는 `8bit` 만 표현되므로, `8bit` 를 벗어난 `1` 은 버리면,
`0000_0000`  이 된다.

이러한 `2의 보수법` 을 사용한다면, 해당 양수값에 `-` 를 붙힌 음수값이 어떠한 `bit` 인지 쉽게 유추가능하다
`1101_1101` 이 있다고 하자, 이 값이 몇일지 계산하려면 다음처럼 한다.
이때, 더했을때 `0000_0000` 이 되는 값은 `0010_0010` 에 `1` 을 더한값인 `0010_0011` 이다.

```sh
  1101_1101
+ 0010_0011
===========
 10000_0000
```

이를 십진수로 표현하면, 
`0010_0011` 은 `32 + 2 + 1` 이므로 `35` 이며,
여기에 `-` 값을 붙이면, `1101_1101` 값인 `-35` 가 된다.

그럼 맞는지 다음을 통해 확인해볼수 있다.

```sh

| signed bit |      표현가능한 수        |
|     1      | 1 | 0 | 1 | 1 | 1 | 0 | 1 |
    - 128     64   0   16  8   4   0   1

-128 + 64 + 0 + 16 + 8 + 4 + 0 + 1 = -35
```

값이 동일한것을 볼수 있다.
이는 `bit` 를 다룰때 매우 유용하게 사용할수 있는 방식이다.
이는 음수뿐만 아니라 양수역시 같은 방식으로 알수있다.

다시 정리해보겠다.
> `"2의 보수법에서 수의 부호를 바꾸려면 먼저 비트를 반전시킨뒤 1을 더하면 된다."`

이제 왜 `byte` 타입이 `-128 ~ 127` 인지 알게 되었다.

`byte` 뿐만 아니라 다른 정수형 타입들 (`byte`, `short`, `int`, `long`) 은 양수와 음수를
구분하기 위해 위와 같은 방식으로 표현했다.

> Java 는 `unsgined` 자료형이 없다. (char 제외) `Java` 언어를 만들때, 불필요한 실수를 제거하기 위해
굳이 만들필요 없다고 판단하여, `unsigned` 자료형을 만들지 않았다고 한다.
>
> 지금의 컴퓨터로는 메모리를 과거처럼 아껴야 하는 상황이 아니므로, 불필요하다고 느끼는것이 현명할지도 모른다.

책에서 다음의 문제를 냈는데, 순간 헷갈려 내용을 다시 정리한다.

```java
public Class PrimitiveTypes {
    public static void main() {
        PrimitiveTypes pt = new PrimitiveTypes();
        pt.checkByte()
    }
    public void checkByte() {
        byte byteMin = (byte)(-128 - 1);
        byte byteMax = (byte)(127 + 1 );
        System.out.println(byteMin);
        System.out.println(byteMax);
    }
}
```

이부분을 처리해보자.
이는 다음처럼 계산할수 있다.

```sh
byte byteMin = -128 - 1
-------------------------
1000_0000 # -128
1111_1111 # -1
==============
0111_1111 # 127

byte byteMax = 127 + 1
-------------------------
0111_1111 # 127
0000_0001 # 1
==============
1000_0000 # -128
```

즉, 결과값은 `127` 과 `-128` 이다.

> 순간 나도 모르게, `-128` 을 `1111_1111` 로 착각해 생각했다...
1000_0000 이 `128` 이며, 앞의 `signed bit` 가 `1` 이니, `-128` 임을 다시 한번 생각하자..

```sh
$ javac PrimitiveTypes.java
$ java PrimitiveTypes

127
-128
```

이러한 특성으로인해, 해당하는 타입의 범위보다 값이 커지거나 작아지면,
최대값은 가장 작은수로, 최소값은 가장 큰수로 변하게 된다.

이러한 특성을 `underflow`, `overflow` 라 한다.

## 정수형 타입의 활용

보통의 정수형은 `int` 와 `long` 을 많이 쓰며, `byte` 와 `short` 는 잘쓰지는 않다.
데이터를 저장할 목적보다는 계산의 목적이 더 강하기 때문이다.

> 앞에서 (byte)-128 - 1 형식으로, 명시적 형변환을 했다.
만약 해당 타입보다 크거나, 작은 값이라면, 
`JAVA` 는 앞의 잘못된 계산으로 예상치못한 값으로 나올수 있으므로,
자동적으로 `int` 로 강제형변환하기 때문이다.
>
>이러한 방식없이 지정한 타입으로 사용하려고 한다면 명시적으로 형변환을 해야 한다.

이러한 기본적인 `int` 형으로 변환하려고 하는 매커니즘으로 인해, `long` 타입을 사용시에도
이 타입이 `long` 이라는 `L` 을 붙혀주는것이 좋다.

```java

public void checkotherTypes() {
    short shortMax = 23767;
    int intMax = 2147483648;
    long longMax = 922337203685477807; // The leteral 922337203685477807 of type int is out of range
}
```

`Error: out of range` 가 나타나는것을 볼수 있다. 
이는 `long` 타입이라고 명시적으로 선언해주지 않았으므로, `int` 타입에서는 사용할수 없는 값이기 때문이다.

> `long` 타입으로 선언하면 되었지, 굳이 다시한번 `L` 타입으로 선언해야 하는지는 의문이기는하다..

다음처럼 `L` 을 붙히면 에러가 사라진다

```java
    long longMax = 922337203685477807L; 
```

## JAVA 의 소수점 처리방식

기본적으로 `Programming Language` 에서 소수점을 처리하는 방식은 `float` 과 `double` 로 사용한다.
이때 이 두가지 타입은 `floating point` 방식으로 소수점을 표현하는데, 이는 정수형과는 다르게
계산시 부정확하다.

> 만약, 돈계산처럼 정확한 계산이 요구될때는 `java.math.BigDecimal` 클래스를 사용하여 처리해야 한다.

이러한 부정확함은 `floating point` 방식과 연관되어 있는데,
구조는 다음과 같다.

```sh
sign | exponent |  mantissa  | 
 (s)      (e)        (m)
```

### sign

이는 `MSB`(Most Signinficant Bit) 라고 하며, 가장 왼쪽의 `bit` 를 사용하여 `양수`, `음수` 를
판단한다.

### exponent

이는 `지수부` 라고 하며, `float` 기준으로 `8bit` 를 차지한다.
이를 알아보려면 다음처럼 계산을 해보도록 한다.

```sh
5.125 = 101.001
```

여기에서 `101.001` 에서 소수점을 가장 왼쪽으로 옮긴다.

```sh
1.01001 -> 101.001 * 2^2
```
이때 옮겨진 소수점은 `2^2` 이므로, `2` 진수의 지수부는 `2` 가된다.
이렇게, 소수점을 이동시키는것을 정규화 시킨다 한다.

이후에, 지수부는 `bias` 값을 더하여 추가한다.
`bias = 127` 이므로, `2 + 127` 이 된다.

>bias 값은 지수값이 음수값이 나올수 있으므로, 
> 8bit 에서 기준이 되는 127 을 더하여 음수인지, 양수인지를 판단하도록 한다.
> 127 값보다 크가나 같다면, 양수이고 127값보다 작다면 음수이다.

이를 표현하면 다음과 같다.

```sh
sign      exponent
| 0 | 1 0 0 0 0 0 0 1 | mantiassa |
```

### mantissa

가수부는 `float` 기준으로 해서 `24bit` 를 가진다.
`1.01001` 로 만들어진 값에서 `소수점 아래 부분` 인 `01001` 을 기입한다.

```sh
sign      exponent                  mantissa
------------------------------------------------------------------------
| 0 | 1 0 0 0 0 0 0 1 | 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 |
```
그럼 이로인해 만들어진 값은 `0_1000_0001_0000_0000_0000_0000_0000_1001` 이다. 

이는 `float` 에 대한 방식이며, `double-precision 64 bit` 인 `double` 은 더 많은
`정밀도` 를 가진다.

이를 정리하면 다음과 같다.

| type | sign(bit) | exponent(bit) | mantissa(bit) |
| :--- | :--- | :--- | :--- |
| float | 1 | 8 | 24 |
| double | 1 | 11 | 52 |

이러한 방식으로인해, `mantissa` 로 저장되거나, `exponent` 로 저장되는 한계가 존제한다.
소수중에 무한소수가 존재하므로, 어쩔수 없이 잘라서 처리해야 하는 경우가 존재하거나,
소수에서 `지수부` 혹은 `가수부` 의 `bit` 수를 넘어서는 소수역시 존재한다.

이러한 경우, 어떻해든 값을 표현해야 하므로, 해당 `bit` 수에 맞게 잘라서 대입한다.
그러므로, 정확한 값이 나오기도 하며, 그렇지 않은 값이 나오기도 한다.

이러한 작동원리를 이해한다면, `float` 및 `double` 에서 오차가 발생하는 이유를 알수있어
조금더 프로그래밍의 이해가 높아질수 있다.

## char 와 boolean

일반적으로 `character` 라고 읽으며, `char` 는 문자열과 관련된 부분으로 사용한다.
그리고 표현시 `"` 가아닌 `'` 으로 감싸야 한다.

```java
public void checkChar() {
    char charMin = '\u0000';
    char charMax = '\uffff';
    System.out.println("["+charMin+"]");
    System.out.println("["+charMax+"]");
}
```

`checkChar` 메서드를 호출하면 다음과 같이 출력된다.

```sh
[ ]
[?]
```

만약 `int` 타입에 문자를 넣는다면, 이는 `int` 형의 숫자로 변경되어 나타난다

```java
int intValue = 'a';
System.out.println("["+intValue+"]")
```

```sh
[97]
```

또한 집접 문자열을 `char` 타입에 넣어 할당도 가능하다

```java
char charA = 'a';
System.out.println(charA) // a
```

`char` 는 보통 문자를 넣어 할당하지만, 숫자 및 `16진수` 숫자 코드를 넣어 사용할수도 있다.
`Java` 에서의 `char` 는 `ASCII` 가 아닌 `Unicode` 를 사용하므로, `1byte` 가 아닌 `2byte`
를 사용한다.

`2byte` 는 `0 ~ 65535` 이므로 총 `65536` 개의 문자집합을 가지고 있다.
즉 `char` 는 최대 `65535` 까지의 숫자값을 가질수 있으며, 이는 `\uffff` 와 같다.

`boolean` 은 간단하다 `true` 와 `false` 인 값이다. 



